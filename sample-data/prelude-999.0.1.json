{"uploader":null,"packageMeta":{"homepage":"https://github.com/purescript/purescript-prelude","repository":{"url":"git://github.com/purescript/purescript-prelude.git","type":"git"},"ignore":["**/.*","bower_components","node_modules","output","test","bower.json","gulpfile.js","package.json"],"name":"purescript-prelude","keywords":["purescript"],"description":"The PureScript Prelude"},"modules":[{"name":"Prelude","comments":null,"declarations":[{"children":[{"code":[["keyword","instance"],["space"],["ident","semigroupUnit"],["space"],["syntax","::"],["space"],["ctor","Semigroup","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"semigroupUnit","type":"instance","sourceSpan":{"start":[406,1],"name":"src/Prelude.purs","end":[409,1]}},{"code":[["keyword","instance"],["space"],["ident","semiringUnit"],["space"],["syntax","::"],["space"],["ctor","Semiring","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"semiringUnit","type":"instance","sourceSpan":{"start":[457,1],"name":"src/Prelude.purs","end":[463,1]}},{"code":[["keyword","instance"],["space"],["ident","ringUnit"],["space"],["syntax","::"],["space"],["ctor","Ring","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"ringUnit","type":"instance","sourceSpan":{"start":[495,1],"name":"src/Prelude.purs","end":[498,1]}},{"code":[["keyword","instance"],["space"],["ident","moduloSemiringUnit"],["space"],["syntax","::"],["space"],["ctor","ModuloSemiring","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"moduloSemiringUnit","type":"instance","sourceSpan":{"start":[530,1],"name":"src/Prelude.purs","end":[534,1]}},{"code":[["keyword","instance"],["space"],["ident","divisionRingUnit"],["space"],["syntax","::"],["space"],["ctor","DivisionRing","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"divisionRingUnit","type":"instance","sourceSpan":{"start":[556,1],"name":"src/Prelude.purs","end":[564,1]}},{"code":[["keyword","instance"],["space"],["ident","numUnit"],["space"],["syntax","::"],["space"],["ctor","Num","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"numUnit","type":"instance","sourceSpan":{"start":[567,1],"name":"src/Prelude.purs","end":[576,1]}},{"code":[["keyword","instance"],["space"],["ident","eqUnit"],["space"],["syntax","::"],["space"],["ctor","Eq","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"eqUnit","type":"instance","sourceSpan":{"start":[606,1],"name":"src/Prelude.purs","end":[609,1]}},{"code":[["keyword","instance"],["space"],["ident","ordUnit"],["space"],["syntax","::"],["space"],["ctor","Ord","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"ordUnit","type":"instance","sourceSpan":{"start":[655,1],"name":"src/Prelude.purs","end":[658,1]}},{"code":[["keyword","instance"],["space"],["ident","boundedUnit"],["space"],["syntax","::"],["space"],["ctor","Bounded","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"boundedUnit","type":"instance","sourceSpan":{"start":[726,1],"name":"src/Prelude.purs","end":[730,1]}},{"code":[["keyword","instance"],["space"],["ident","boundedOrdUnit"],["space"],["syntax","::"],["space"],["ctor","BoundedOrd","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"boundedOrdUnit","type":"instance","sourceSpan":{"start":[750,1],"name":"src/Prelude.purs","end":[751,1]}},{"code":[["keyword","instance"],["space"],["ident","booleanAlgebraUnit"],["space"],["syntax","::"],["space"],["ctor","BooleanAlgebra","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"booleanAlgebraUnit","type":"instance","sourceSpan":{"start":[793,1],"name":"src/Prelude.purs","end":[798,1]}},{"code":[["keyword","instance"],["space"],["ident","showUnit"],["space"],["syntax","::"],["space"],["ctor","Show","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"showUnit","type":"instance","sourceSpan":{"start":[843,1],"name":"src/Prelude.purs","end":[846,1]}}],"code":[["keyword","newtype"],["space"],["ctor","Unit",null]],"comments":"The `Unit` type has a single inhabitant, called `unit`. It represents\nvalues with no computational content.\n\n`Unit` is often used, wrapped in a monadic type constructor, as the\nreturn type of a computation where only\nthe _effects_ are important.\n","title":"Unit","fixity":null,"sourceSpan":{"start":[35,1],"name":"src/Prelude.purs","end":[38,1]}},{"children":[],"code":[["ident","unit"],["space"],["syntax","::"],["space"],["ctor","Unit","Prelude"]],"comments":"`unit` is the sole inhabitant of the `Unit` type.\n","title":"unit","fixity":null,"sourceSpan":{"start":[38,1],"name":"src/Prelude.purs","end":[39,1]}},{"children":[],"code":[["ident","($)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"]],"comments":"Applies a function to its argument.\n\n```purescript\nlength $ groupBy productCategory $ filter isInStock $ products\n```\n\nis equivalent to:\n\n```purescript\nlength (groupBy productCategory (filter isInStock products))\n```\n\n`($)` is different from [`(#)`](#-2) because it is right-infix instead of\nleft: `a $ b $ c $ d x = a $ (b $ (c $ (d $ x))) = a (b (c (d x)))`\n","title":"($)","fixity":{"associativity":"infixr","precedence":0},"sourceSpan":{"start":[58,1],"name":"src/Prelude.purs","end":[59,1]}},{"children":[],"code":[["ident","(#)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["ident","a"],["space"],["syntax","->"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","b"]],"comments":"Applies an argument to a function.\n\n```purescript\nproducts # filter isInStock # groupBy productCategory # length\n```\n\nis equivalent to:\n\n```purescript\nlength (groupBy productCategory (filter isInStock products))\n```\n\n`(#)` is different from [`($)`](#-1) because it is left-infix instead of\nright: `x # a # b # c # d = (((x # a) # b) # c) # d = d (c (b (a x)))`\n","title":"(#)","fixity":{"associativity":"infixl","precedence":1},"sourceSpan":{"start":[75,1],"name":"src/Prelude.purs","end":[76,1]}},{"children":[],"code":[["ident","flip"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["space"],["ident","b"],["space"],["ident","c"],["syntax","."],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["space"],["syntax","->"],["space"],["ident","c"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","b"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","c"]],"comments":"Flips the order of the arguments to a function of two arguments.\n\n```purescript\nflip const 1 2 = const 2 1 = 2\n```\n","title":"flip","fixity":null,"sourceSpan":{"start":[83,1],"name":"src/Prelude.purs","end":[84,1]}},{"children":[],"code":[["ident","const"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":"Returns its first argument and ignores its second.\n\n```purescript\nconst 1 \"hello\" = 1\n```\n","title":"const","fixity":null,"sourceSpan":{"start":[91,1],"name":"src/Prelude.purs","end":[92,1]}},{"children":[],"code":[["ident","asTypeOf"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":"This function returns its first argument, and can be used to assert type\nequalities. This can be useful when types are otherwise ambiguous.\n\n```purescript\nmain = print $ [] `asTypeOf` [0]\n```\n\nIf instead, we had written `main = print []`, the type of the argument\n`[]` would have been ambiguous, resulting in a compile-time error.\n","title":"asTypeOf","fixity":null,"sourceSpan":{"start":[103,1],"name":"src/Prelude.purs","end":[104,1]}},{"children":[],"code":[["ident","otherwise"],["space"],["syntax","::"],["space"],["ctor","Boolean",null]],"comments":"An alias for `true`, which can be useful in guard clauses:\n\n```purescript\nmax x y | x >= y    = x\n        | otherwise = y\n```\n","title":"otherwise","fixity":null,"sourceSpan":{"start":[112,1],"name":"src/Prelude.purs","end":[113,1]}},{"children":[{"code":[["ident","compose"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","b"],["space"],["ident","c"],["space"],["ident","d"],["syntax","."],["space"],["ident","a"],["space"],["ident","c"],["space"],["ident","d"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["ident","b"],["space"],["ident","c"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["ident","b"],["space"],["ident","d"]],"comments":null,"title":"compose","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","semigroupoidFn"],["space"],["syntax","::"],["space"],["ctor","Semigroupoid","Prelude"],["space"],["ctor","Function","Prim"]],"comments":null,"title":"semigroupoidFn","type":"instance","sourceSpan":{"start":[127,1],"name":"src/Prelude.purs","end":[130,1]}}],"code":[["keyword","class"],["space"],["ctor","Semigroupoid",null],["space"],["ident","a"],["space"],["keyword","where"]],"comments":"A `Semigroupoid` is similar to a [`Category`](#category) but does not\nrequire an identity element `id`, just composable morphisms.\n\n`Semigroupoid`s must satisfy the following law:\n\n- Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`\n\nOne example of a `Semigroupoid` is the function type constructor `(->)`,\nwith `(<<<)` defined as function composition.\n","title":"Semigroupoid","fixity":null,"sourceSpan":{"start":[124,1],"name":"src/Prelude.purs","end":[127,1]}},{"children":[],"code":[["ident","(<<<)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["space"],["ident","b"],["space"],["ident","c"],["space"],["ident","d"],["syntax","."],["space"],["syntax","("],["ctor","Semigroupoid","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["ident","c"],["space"],["ident","d"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["ident","b"],["space"],["ident","c"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["ident","b"],["space"],["ident","d"]],"comments":"`(<<<)` is an alias for `compose`.\n","title":"(<<<)","fixity":{"associativity":"infixr","precedence":9},"sourceSpan":{"start":[134,1],"name":"src/Prelude.purs","end":[135,1]}},{"children":[],"code":[["ident","(>>>)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["space"],["ident","b"],["space"],["ident","c"],["space"],["ident","d"],["syntax","."],["space"],["syntax","("],["ctor","Semigroupoid","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["ident","b"],["space"],["ident","c"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["ident","c"],["space"],["ident","d"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["ident","b"],["space"],["ident","d"]],"comments":"Forwards composition, or `(<<<)` with its arguments reversed.\n","title":"(>>>)","fixity":{"associativity":"infixr","precedence":9},"sourceSpan":{"start":[138,1],"name":"src/Prelude.purs","end":[139,1]}},{"children":[{"code":[["ident","id"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","t"],["syntax","."],["space"],["ident","a"],["space"],["ident","t"],["space"],["ident","t"]],"comments":null,"title":"id","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","categoryFn"],["space"],["syntax","::"],["space"],["ctor","Category","Prelude"],["space"],["ctor","Function","Prim"]],"comments":null,"title":"categoryFn","type":"instance","sourceSpan":{"start":[152,1],"name":"src/Prelude.purs","end":[166,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","Semigroupoid","Prelude"],["space"],["ident","a"],["syntax",") <="],["space"],["ctor","Category",null],["space"],["ident","a"],["space"],["keyword","where"]],"comments":"`Category`s consist of objects and composable morphisms between them, and\nas such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`\nmust have an identity element.\n\nInstances must satisfy the following law in addition to the\n`Semigroupoid` law:\n\n- Identity: `id <<< p = p <<< id = p`\n","title":"Category","fixity":null,"sourceSpan":{"start":[149,1],"name":"src/Prelude.purs","end":[152,1]}},{"children":[{"code":[["ident","map"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","b"]],"comments":null,"title":"map","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","functorFn"],["space"],["syntax","::"],["space"],["ctor","Functor","Prelude"],["space"],["syntax","("],["ctor","Function","Prim"],["space"],["ident","r"],["syntax",")"]],"comments":null,"title":"functorFn","type":"instance","sourceSpan":{"start":[169,1],"name":"src/Prelude.purs","end":[172,1]}},{"code":[["keyword","instance"],["space"],["ident","functorArray"],["space"],["syntax","::"],["space"],["ctor","Functor","Prelude"],["space"],["ctor","Array","Prim"]],"comments":null,"title":"functorArray","type":"instance","sourceSpan":{"start":[172,1],"name":"src/Prelude.purs","end":[175,1]}}],"code":[["keyword","class"],["space"],["ctor","Functor",null],["space"],["ident","f"],["space"],["keyword","where"]],"comments":"A `Functor` is a type constructor which supports a mapping operation\n`(<$>)`.\n\n`(<$>)` can be used to turn functions `a -> b` into functions\n`f a -> f b` whose argument and return types use the type constructor `f`\nto represent some computational context.\n\nInstances must satisfy the following laws:\n\n- Identity: `(<$>) id = id`\n- Composition: `(<$>) (f <<< g) = (f <$>) <<< (g <$>)`\n","title":"Functor","fixity":null,"sourceSpan":{"start":[166,1],"name":"src/Prelude.purs","end":[169,1]}},{"children":[],"code":[["ident","(<$>)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","f"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["syntax","("],["ctor","Functor","Prelude"],["space"],["ident","f"],["syntax",")"],["space"],["syntax","=>"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","b"]],"comments":"`(<$>)` is an alias for `map`\n","title":"(<$>)","fixity":{"associativity":"infixl","precedence":4},"sourceSpan":{"start":[181,1],"name":"src/Prelude.purs","end":[182,1]}},{"children":[],"code":[["ident","(<#>)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","f"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["syntax","("],["ctor","Functor","Prelude"],["space"],["ident","f"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","f"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","b"]],"comments":"`(<#>)` is `(<$>)` with its arguments reversed. For example:\n\n```purescript\n[1, 2, 3] <#> \\n -> n * n\n```\n","title":"(<#>)","fixity":{"associativity":"infixl","precedence":1},"sourceSpan":{"start":[189,1],"name":"src/Prelude.purs","end":[190,1]}},{"children":[],"code":[["ident","void"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","f"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Functor","Prelude"],["space"],["ident","f"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","f"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ctor","Unit","Prelude"]],"comments":"The `void` function is used to ignore the type wrapped by a\n[`Functor`](#functor), replacing it with `Unit` and keeping only the type\ninformation provided by the type constructor itself.\n\n`void` is often useful when using `do` notation to change the return type\nof a monadic computation:\n\n```purescript\nmain = forE 1 10 \\n -> void do\n  print n\n  print (n * n)\n```\n","title":"void","fixity":null,"sourceSpan":{"start":[204,1],"name":"src/Prelude.purs","end":[205,1]}},{"children":[{"code":[["ident","apply"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["ident","f"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","b"]],"comments":null,"title":"apply","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","applyFn"],["space"],["syntax","::"],["space"],["ctor","Apply","Prelude"],["space"],["syntax","("],["ctor","Function","Prim"],["space"],["ident","r"],["syntax",")"]],"comments":null,"title":"applyFn","type":"instance","sourceSpan":{"start":[232,1],"name":"src/Prelude.purs","end":[235,1]}},{"code":[["keyword","instance"],["space"],["ident","applyArray"],["space"],["syntax","::"],["space"],["ctor","Apply","Prelude"],["space"],["ctor","Array","Prim"]],"comments":null,"title":"applyArray","type":"instance","sourceSpan":{"start":[235,1],"name":"src/Prelude.purs","end":[238,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","Functor","Prelude"],["space"],["ident","f"],["syntax",") <="],["space"],["ctor","Apply",null],["space"],["ident","f"],["space"],["keyword","where"]],"comments":"The `Apply` class provides the `(<*>)` which is used to apply a function\nto an argument under a type constructor.\n\n`Apply` can be used to lift functions of two or more arguments to work on\nvalues wrapped with the type constructor `f`. It might also be understood\nin terms of the `lift2` function:\n\n```purescript\nlift2 :: forall f a b c. (Apply f) => (a -> b -> c) -> f a -> f b -> f c\nlift2 f a b = f <$> a <*> b\n```\n\n`(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts\nthe function application operator `($)` to arguments wrapped with the\ntype constructor `f`.\n\nInstances must satisfy the following law in addition to the `Functor`\nlaws:\n\n- Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`\n\nFormally, `Apply` represents a strong lax semi-monoidal endofunctor.\n","title":"Apply","fixity":null,"sourceSpan":{"start":[229,1],"name":"src/Prelude.purs","end":[232,1]}},{"children":[],"code":[["ident","(<*>)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","f"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["syntax","("],["ctor","Apply","Prelude"],["space"],["ident","f"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","f"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","b"]],"comments":"`(<*>)` is an alias for `apply`.\n","title":"(<*>)","fixity":{"associativity":"infixl","precedence":4},"sourceSpan":{"start":[241,1],"name":"src/Prelude.purs","end":[242,1]}},{"children":[{"code":[["ident","pure"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","a"]],"comments":null,"title":"pure","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","applicativeFn"],["space"],["syntax","::"],["space"],["ctor","Applicative","Prelude"],["space"],["syntax","("],["ctor","Function","Prim"],["space"],["ident","r"],["syntax",")"]],"comments":null,"title":"applicativeFn","type":"instance","sourceSpan":{"start":[265,1],"name":"src/Prelude.purs","end":[268,1]}},{"code":[["keyword","instance"],["space"],["ident","applicativeArray"],["space"],["syntax","::"],["space"],["ctor","Applicative","Prelude"],["space"],["ctor","Array","Prim"]],"comments":null,"title":"applicativeArray","type":"instance","sourceSpan":{"start":[268,1],"name":"src/Prelude.purs","end":[272,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","Apply","Prelude"],["space"],["ident","f"],["syntax",") <="],["space"],["ctor","Applicative",null],["space"],["ident","f"],["space"],["keyword","where"]],"comments":"The `Applicative` type class extends the [`Apply`](#apply) type class\nwith a `pure` function, which can be used to create values of type `f a`\nfrom values of type `a`.\n\nWhere [`Apply`](#apply) provides the ability to lift functions of two or\nmore arguments to functions whose arguments are wrapped using `f`, and\n[`Functor`](#functor) provides the ability to lift functions of one\nargument, `pure` can be seen as the function which lifts functions of\n_zero_ arguments. That is, `Applicative` functors support a lifting\noperation for any number of function arguments.\n\nInstances must satisfy the following laws in addition to the `Apply`\nlaws:\n\n- Identity: `(pure id) <*> v = v`\n- Composition: `(pure <<<) <*> f <*> g <*> h = f <*> (g <*> h)`\n- Homomorphism: `(pure f) <*> (pure x) = pure (f x)`\n- Interchange: `u <*> (pure y) = (pure ($ y)) <*> u`\n","title":"Applicative","fixity":null,"sourceSpan":{"start":[262,1],"name":"src/Prelude.purs","end":[265,1]}},{"children":[],"code":[["ident","return"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","m"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Applicative","Prelude"],["space"],["ident","m"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","m"],["space"],["ident","a"]],"comments":"`return` is an alias for `pure`.\n","title":"return","fixity":null,"sourceSpan":{"start":[272,1],"name":"src/Prelude.purs","end":[273,1]}},{"children":[],"code":[["ident","liftA1"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","f"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["syntax","("],["ctor","Applicative","Prelude"],["space"],["ident","f"],["syntax",")"],["space"],["syntax","=>"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","f"],["space"],["ident","b"]],"comments":"`liftA1` provides a default implementation of `(<$>)` for any\n[`Applicative`](#applicative) functor, without using `(<$>)` as provided\nby the [`Functor`](#functor)-[`Applicative`](#applicative) superclass\nrelationship.\n\n`liftA1` can therefore be used to write [`Functor`](#functor) instances\nas follows:\n\n```purescript\ninstance functorF :: Functor F where\n  map = liftA1\n```\n","title":"liftA1","fixity":null,"sourceSpan":{"start":[287,1],"name":"src/Prelude.purs","end":[288,1]}},{"children":[{"code":[["ident","bind"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["ident","m"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","m"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","m"],["space"],["ident","b"]],"comments":null,"title":"bind","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","bindFn"],["space"],["syntax","::"],["space"],["ctor","Bind","Prelude"],["space"],["syntax","("],["ctor","Function","Prim"],["space"],["ident","r"],["syntax",")"]],"comments":null,"title":"bindFn","type":"instance","sourceSpan":{"start":[319,1],"name":"src/Prelude.purs","end":[322,1]}},{"code":[["keyword","instance"],["space"],["ident","bindArray"],["space"],["syntax","::"],["space"],["ctor","Bind","Prelude"],["space"],["ctor","Array","Prim"]],"comments":null,"title":"bindArray","type":"instance","sourceSpan":{"start":[322,1],"name":"src/Prelude.purs","end":[325,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","Apply","Prelude"],["space"],["ident","m"],["syntax",") <="],["space"],["ctor","Bind",null],["space"],["ident","m"],["space"],["keyword","where"]],"comments":"The `Bind` type class extends the [`Apply`](#apply) type class with a\n\"bind\" operation `(>>=)` which composes computations in sequence, using\nthe return value of one computation to determine the next computation.\n\nThe `>>=` operator can also be expressed using `do` notation, as follows:\n\n```purescript\nx >>= f = do y <- x\n             f y\n```\n\nwhere the function argument of `f` is given the name `y`.\n\nInstances must satisfy the following law in addition to the `Apply`\nlaws:\n\n- Associativity: `(x >>= f) >>= g = x >>= (\\k => f k >>= g)`\n\nAssociativity tells us that we can regroup operations which use `do`\nnotation so that we can unambiguously write, for example:\n\n```purescript\ndo x <- m1\n   y <- m2 x\n   m3 x y\n```\n","title":"Bind","fixity":null,"sourceSpan":{"start":[316,1],"name":"src/Prelude.purs","end":[319,1]}},{"children":[],"code":[["ident","(>>=)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","m"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["syntax","("],["ctor","Bind","Prelude"],["space"],["ident","m"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","m"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","m"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","m"],["space"],["ident","b"]],"comments":"`(>>=)` is an alias for `bind`.\n","title":"(>>=)","fixity":{"associativity":"infixl","precedence":1},"sourceSpan":{"start":[330,1],"name":"src/Prelude.purs","end":[331,1]}},{"children":[{"code":[["keyword","instance"],["space"],["ident","monadFn"],["space"],["syntax","::"],["space"],["ctor","Monad","Prelude"],["space"],["syntax","("],["ctor","Function","Prim"],["space"],["ident","r"],["syntax",")"]],"comments":null,"title":"monadFn","type":"instance","sourceSpan":{"start":[345,1],"name":"src/Prelude.purs","end":[346,1]}},{"code":[["keyword","instance"],["space"],["ident","monadArray"],["space"],["syntax","::"],["space"],["ctor","Monad","Prelude"],["space"],["ctor","Array","Prim"]],"comments":null,"title":"monadArray","type":"instance","sourceSpan":{"start":[346,1],"name":"src/Prelude.purs","end":[359,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","Applicative","Prelude"],["space"],["ident","m"],["syntax",","],["space"],["ctor","Bind","Prelude"],["space"],["ident","m"],["syntax",") <="],["space"],["ctor","Monad",null],["space"],["ident","m"]],"comments":"The `Monad` type class combines the operations of the `Bind` and\n`Applicative` type classes. Therefore, `Monad` instances represent type\nconstructors which support sequential composition, and also lifting of\nfunctions of arbitrary arity.\n\nInstances must satisfy the following laws in addition to the\n`Applicative` and `Bind` laws:\n\n- Left Identity: `pure x >>= f = f x`\n- Right Identity: `x >>= pure = x`\n","title":"Monad","fixity":null,"sourceSpan":{"start":[343,1],"name":"src/Prelude.purs","end":[345,1]}},{"children":[],"code":[["ident","liftM1"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","m"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["syntax","("],["ctor","Monad","Prelude"],["space"],["ident","m"],["syntax",")"],["space"],["syntax","=>"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","m"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","m"],["space"],["ident","b"]],"comments":"`liftM1` provides a default implementation of `(<$>)` for any\n[`Monad`](#monad), without using `(<$>)` as provided by the\n[`Functor`](#functor)-[`Monad`](#monad) superclass relationship.\n\n`liftM1` can therefore be used to write [`Functor`](#functor) instances\nas follows:\n\n```purescript\ninstance functorF :: Functor F where\n  map = liftM1\n```\n","title":"liftM1","fixity":null,"sourceSpan":{"start":[359,1],"name":"src/Prelude.purs","end":[360,1]}},{"children":[],"code":[["ident","ap"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","m"],["space"],["ident","a"],["space"],["ident","b"],["syntax","."],["space"],["syntax","("],["ctor","Monad","Prelude"],["space"],["ident","m"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","m"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"],["space"],["syntax","->"],["space"],["ident","m"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","m"],["space"],["ident","b"]],"comments":"`ap` provides a default implementation of `(<*>)` for any\n[`Monad`](#monad), without using `(<*>)` as provided by the\n[`Apply`](#apply)-[`Monad`](#monad) superclass relationship.\n\n`ap` can therefore be used to write [`Apply`](#apply) instances as\nfollows:\n\n```purescript\ninstance applyF :: Apply F where\n  apply = ap\n```\n","title":"ap","fixity":null,"sourceSpan":{"start":[375,1],"name":"src/Prelude.purs","end":[376,1]}},{"children":[{"code":[["ident","append"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":null,"title":"append","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","semigroupString"],["space"],["syntax","::"],["space"],["ctor","Semigroup","Prelude"],["space"],["ctor","String","Prim"]],"comments":null,"title":"semigroupString","type":"instance","sourceSpan":{"start":[403,1],"name":"src/Prelude.purs","end":[406,1]}},{"code":[["keyword","instance"],["space"],["ident","semigroupUnit"],["space"],["syntax","::"],["space"],["ctor","Semigroup","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"semigroupUnit","type":"instance","sourceSpan":{"start":[406,1],"name":"src/Prelude.purs","end":[409,1]}},{"code":[["keyword","instance"],["space"],["ident","semigroupFn"],["space"],["syntax","::"],["space"],["syntax","("],["ctor","Semigroup","Prelude"],["space"],["ident","s'"],["syntax",") =>"],["space"],["ctor","Semigroup","Prelude"],["space"],["syntax","("],["ident","s"],["space"],["syntax","->"],["space"],["ident","s'"],["syntax",")"]],"comments":null,"title":"semigroupFn","type":"instance","sourceSpan":{"start":[409,1],"name":"src/Prelude.purs","end":[412,1]}},{"code":[["keyword","instance"],["space"],["ident","semigroupOrdering"],["space"],["syntax","::"],["space"],["ctor","Semigroup","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"semigroupOrdering","type":"instance","sourceSpan":{"start":[412,1],"name":"src/Prelude.purs","end":[417,1]}},{"code":[["keyword","instance"],["space"],["ident","semigroupArray"],["space"],["syntax","::"],["space"],["ctor","Semigroup","Prelude"],["space"],["syntax","("],["ctor","Array","Prim"],["space"],["ident","a"],["syntax",")"]],"comments":null,"title":"semigroupArray","type":"instance","sourceSpan":{"start":[417,1],"name":"src/Prelude.purs","end":[420,1]}}],"code":[["keyword","class"],["space"],["ctor","Semigroup",null],["space"],["ident","a"],["space"],["keyword","where"]],"comments":"The `Semigroup` type class identifies an associative operation on a type.\n\nInstances are required to satisfy the following law:\n\n- Associativity: `(x <> y) <> z = x <> (y <> z)`\n\nOne example of a `Semigroup` is `String`, with `(<>)` defined as string\nconcatenation.\n","title":"Semigroup","fixity":null,"sourceSpan":{"start":[389,1],"name":"src/Prelude.purs","end":[392,1]}},{"children":[],"code":[["ident","(<>)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","s"],["syntax","."],["space"],["syntax","("],["ctor","Semigroup","Prelude"],["space"],["ident","s"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","s"],["space"],["syntax","->"],["space"],["ident","s"],["space"],["syntax","->"],["space"],["ident","s"]],"comments":"`(<>)` is an alias for `append`.\n","title":"(<>)","fixity":{"associativity":"infixr","precedence":5},"sourceSpan":{"start":[396,1],"name":"src/Prelude.purs","end":[397,1]}},{"children":[],"code":[["ident","(++)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","s"],["syntax","."],["space"],["syntax","("],["ctor","Semigroup","Prelude"],["space"],["ident","s"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","s"],["space"],["syntax","->"],["space"],["ident","s"],["space"],["syntax","->"],["space"],["ident","s"]],"comments":"`(++)` is an alternative alias for `append`.\n","title":"(++)","fixity":{"associativity":"infixr","precedence":5},"sourceSpan":{"start":[400,1],"name":"src/Prelude.purs","end":[401,1]}},{"children":[{"code":[["ident","add"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":null,"title":"add","type":"typeClassMember","sourceSpan":null},{"code":[["ident","zero"],["space"],["syntax","::"],["space"],["ident","a"]],"comments":null,"title":"zero","type":"typeClassMember","sourceSpan":null},{"code":[["ident","mul"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":null,"title":"mul","type":"typeClassMember","sourceSpan":null},{"code":[["ident","one"],["space"],["syntax","::"],["space"],["ident","a"]],"comments":null,"title":"one","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","semiringInt"],["space"],["syntax","::"],["space"],["ctor","Semiring","Prelude"],["space"],["ctor","Int","Prim"]],"comments":null,"title":"semiringInt","type":"instance","sourceSpan":{"start":[445,1],"name":"src/Prelude.purs","end":[451,1]}},{"code":[["keyword","instance"],["space"],["ident","semiringNumber"],["space"],["syntax","::"],["space"],["ctor","Semiring","Prelude"],["space"],["ctor","Number","Prim"]],"comments":null,"title":"semiringNumber","type":"instance","sourceSpan":{"start":[451,1],"name":"src/Prelude.purs","end":[457,1]}},{"code":[["keyword","instance"],["space"],["ident","semiringUnit"],["space"],["syntax","::"],["space"],["ctor","Semiring","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"semiringUnit","type":"instance","sourceSpan":{"start":[457,1],"name":"src/Prelude.purs","end":[463,1]}}],"code":[["keyword","class"],["space"],["ctor","Semiring",null],["space"],["ident","a"],["space"],["keyword","where"]],"comments":"The `Semiring` class is for types that support an addition and\nmultiplication operation.\n\nInstances must satisfy the following laws:\n\n- Commutative monoid under addition:\n  - Associativity: `(a + b) + c = a + (b + c)`\n  - Identity: `zero + a = a + zero = a`\n  - Commutative: `a + b = b + a`\n- Monoid under multiplication:\n  - Associativity: `(a * b) * c = a * (b * c)`\n  - Identity: `one * a = a * one = a`\n- Multiplication distributes over addition:\n  - Left distributivity: `a * (b + c) = (a * b) + (a * c)`\n  - Right distributivity: `(a + b) * c = (a * c) + (b * c)`\n- Annihiliation: `zero * a = a * zero = zero`\n","title":"Semiring","fixity":null,"sourceSpan":{"start":[439,1],"name":"src/Prelude.purs","end":[445,1]}},{"children":[],"code":[["ident","(+)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Semiring","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":"`(+)` is an alias for `add`.\n","title":"(+)","fixity":{"associativity":"infixl","precedence":6},"sourceSpan":{"start":[467,1],"name":"src/Prelude.purs","end":[468,1]}},{"children":[],"code":[["ident","(*)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Semiring","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":"`(*)` is an alias for `mul`.\n","title":"(*)","fixity":{"associativity":"infixl","precedence":7},"sourceSpan":{"start":[471,1],"name":"src/Prelude.purs","end":[472,1]}},{"children":[{"code":[["ident","sub"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":null,"title":"sub","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","ringInt"],["space"],["syntax","::"],["space"],["ctor","Ring","Prelude"],["space"],["ctor","Int","Prim"]],"comments":null,"title":"ringInt","type":"instance","sourceSpan":{"start":[489,1],"name":"src/Prelude.purs","end":[492,1]}},{"code":[["keyword","instance"],["space"],["ident","ringNumber"],["space"],["syntax","::"],["space"],["ctor","Ring","Prelude"],["space"],["ctor","Number","Prim"]],"comments":null,"title":"ringNumber","type":"instance","sourceSpan":{"start":[492,1],"name":"src/Prelude.purs","end":[495,1]}},{"code":[["keyword","instance"],["space"],["ident","ringUnit"],["space"],["syntax","::"],["space"],["ctor","Ring","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"ringUnit","type":"instance","sourceSpan":{"start":[495,1],"name":"src/Prelude.purs","end":[498,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","Semiring","Prelude"],["space"],["ident","a"],["syntax",") <="],["space"],["ctor","Ring",null],["space"],["ident","a"],["space"],["keyword","where"]],"comments":"The `Ring` class is for types that support addition, multiplication,\nand subtraction operations.\n\nInstances must satisfy the following law in addition to the `Semiring`\nlaws:\n\n- Additive inverse: `a - a = (zero - a) + a = zero`\n","title":"Ring","fixity":null,"sourceSpan":{"start":[486,1],"name":"src/Prelude.purs","end":[489,1]}},{"children":[],"code":[["ident","(-)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Ring","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":"`(-)` is an alias for `sub`.\n","title":"(-)","fixity":{"associativity":"infixl","precedence":6},"sourceSpan":{"start":[501,1],"name":"src/Prelude.purs","end":[502,1]}},{"children":[],"code":[["ident","negate"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Ring","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":"`negate x` can be used as a shorthand for `zero - x`.\n","title":"negate","fixity":null,"sourceSpan":{"start":[505,1],"name":"src/Prelude.purs","end":[506,1]}},{"children":[{"code":[["ident","div"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":null,"title":"div","type":"typeClassMember","sourceSpan":null},{"code":[["ident","mod"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":null,"title":"mod","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","moduloSemiringInt"],["space"],["syntax","::"],["space"],["ctor","ModuloSemiring","Prelude"],["space"],["ctor","Int","Prim"]],"comments":null,"title":"moduloSemiringInt","type":"instance","sourceSpan":{"start":[522,1],"name":"src/Prelude.purs","end":[526,1]}},{"code":[["keyword","instance"],["space"],["ident","moduloSemiringNumber"],["space"],["syntax","::"],["space"],["ctor","ModuloSemiring","Prelude"],["space"],["ctor","Number","Prim"]],"comments":null,"title":"moduloSemiringNumber","type":"instance","sourceSpan":{"start":[526,1],"name":"src/Prelude.purs","end":[530,1]}},{"code":[["keyword","instance"],["space"],["ident","moduloSemiringUnit"],["space"],["syntax","::"],["space"],["ctor","ModuloSemiring","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"moduloSemiringUnit","type":"instance","sourceSpan":{"start":[530,1],"name":"src/Prelude.purs","end":[534,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","Semiring","Prelude"],["space"],["ident","a"],["syntax",") <="],["space"],["ctor","ModuloSemiring",null],["space"],["ident","a"],["space"],["keyword","where"]],"comments":"The `ModuloSemiring` class is for types that support addition,\nmultiplication, division, and modulo (division remainder) operations.\n\nInstances must satisfy the following law in addition to the `Semiring`\nlaws:\n\n- Remainder: `a / b * b + (a `mod` b) = a`\n","title":"ModuloSemiring","fixity":null,"sourceSpan":{"start":[518,1],"name":"src/Prelude.purs","end":[522,1]}},{"children":[],"code":[["ident","(/)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","ModuloSemiring","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":"`(/)` is an alias for `div`.\n","title":"(/)","fixity":{"associativity":"infixl","precedence":7},"sourceSpan":{"start":[537,1],"name":"src/Prelude.purs","end":[538,1]}},{"children":[{"code":[["keyword","instance"],["space"],["ident","divisionRingNumber"],["space"],["syntax","::"],["space"],["ctor","DivisionRing","Prelude"],["space"],["ctor","Number","Prim"]],"comments":null,"title":"divisionRingNumber","type":"instance","sourceSpan":{"start":[555,1],"name":"src/Prelude.purs","end":[556,1]}},{"code":[["keyword","instance"],["space"],["ident","divisionRingUnit"],["space"],["syntax","::"],["space"],["ctor","DivisionRing","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"divisionRingUnit","type":"instance","sourceSpan":{"start":[556,1],"name":"src/Prelude.purs","end":[564,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","Ring","Prelude"],["space"],["ident","a"],["syntax",","],["space"],["ctor","ModuloSemiring","Prelude"],["space"],["ident","a"],["syntax",") <="],["space"],["ctor","DivisionRing",null],["space"],["ident","a"]],"comments":"A `Ring` where every nonzero element has a multiplicative inverse.\n\nInstances must satisfy the following law in addition to the `Ring` and\n`ModuloSemiring` laws:\n\n- Multiplicative inverse: `(one / x) * x = one`\n\nAs a consequence of this ```a `mod` b = zero``` as no divide operation\nwill have a remainder.\n","title":"DivisionRing","fixity":null,"sourceSpan":{"start":[553,1],"name":"src/Prelude.purs","end":[555,1]}},{"children":[{"code":[["keyword","instance"],["space"],["ident","numNumber"],["space"],["syntax","::"],["space"],["ctor","Num","Prelude"],["space"],["ctor","Number","Prim"]],"comments":null,"title":"numNumber","type":"instance","sourceSpan":{"start":[566,1],"name":"src/Prelude.purs","end":[567,1]}},{"code":[["keyword","instance"],["space"],["ident","numUnit"],["space"],["syntax","::"],["space"],["ctor","Num","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"numUnit","type":"instance","sourceSpan":{"start":[567,1],"name":"src/Prelude.purs","end":[576,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","DivisionRing","Prelude"],["space"],["ident","a"],["syntax",") <="],["space"],["ctor","Num",null],["space"],["ident","a"]],"comments":"The `Num` class is for types that are commutative fields.\n\nInstances must satisfy the following law in addition to the\n`DivisionRing` laws:\n\n- Commutative multiplication: `a * b = b * a`\n","title":"Num","fixity":null,"sourceSpan":{"start":[564,1],"name":"src/Prelude.purs","end":[566,1]}},{"children":[{"code":[["ident","eq"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ctor","Boolean","Prim"]],"comments":null,"title":"eq","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","eqBoolean"],["space"],["syntax","::"],["space"],["ctor","Eq","Prelude"],["space"],["ctor","Boolean","Prim"]],"comments":null,"title":"eqBoolean","type":"instance","sourceSpan":{"start":[591,1],"name":"src/Prelude.purs","end":[594,1]}},{"code":[["keyword","instance"],["space"],["ident","eqInt"],["space"],["syntax","::"],["space"],["ctor","Eq","Prelude"],["space"],["ctor","Int","Prim"]],"comments":null,"title":"eqInt","type":"instance","sourceSpan":{"start":[594,1],"name":"src/Prelude.purs","end":[597,1]}},{"code":[["keyword","instance"],["space"],["ident","eqNumber"],["space"],["syntax","::"],["space"],["ctor","Eq","Prelude"],["space"],["ctor","Number","Prim"]],"comments":null,"title":"eqNumber","type":"instance","sourceSpan":{"start":[597,1],"name":"src/Prelude.purs","end":[600,1]}},{"code":[["keyword","instance"],["space"],["ident","eqChar"],["space"],["syntax","::"],["space"],["ctor","Eq","Prelude"],["space"],["ctor","Char","Prim"]],"comments":null,"title":"eqChar","type":"instance","sourceSpan":{"start":[600,1],"name":"src/Prelude.purs","end":[603,1]}},{"code":[["keyword","instance"],["space"],["ident","eqString"],["space"],["syntax","::"],["space"],["ctor","Eq","Prelude"],["space"],["ctor","String","Prim"]],"comments":null,"title":"eqString","type":"instance","sourceSpan":{"start":[603,1],"name":"src/Prelude.purs","end":[606,1]}},{"code":[["keyword","instance"],["space"],["ident","eqUnit"],["space"],["syntax","::"],["space"],["ctor","Eq","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"eqUnit","type":"instance","sourceSpan":{"start":[606,1],"name":"src/Prelude.purs","end":[609,1]}},{"code":[["keyword","instance"],["space"],["ident","eqArray"],["space"],["syntax","::"],["space"],["syntax","("],["ctor","Eq","Prelude"],["space"],["ident","a"],["syntax",") =>"],["space"],["ctor","Eq","Prelude"],["space"],["syntax","("],["ctor","Array","Prim"],["space"],["ident","a"],["syntax",")"]],"comments":null,"title":"eqArray","type":"instance","sourceSpan":{"start":[609,1],"name":"src/Prelude.purs","end":[612,1]}},{"code":[["keyword","instance"],["space"],["ident","eqOrdering"],["space"],["syntax","::"],["space"],["ctor","Eq","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"eqOrdering","type":"instance","sourceSpan":{"start":[612,1],"name":"src/Prelude.purs","end":[618,1]}}],"code":[["keyword","class"],["space"],["ctor","Eq",null],["space"],["ident","a"],["space"],["keyword","where"]],"comments":"The `Eq` type class represents types which support decidable equality.\n\n`Eq` instances should satisfy the following laws:\n\n- Reflexivity: `x == x = true`\n- Symmetry: `x == y = y == x`\n- Transitivity: if `x == y` and `y == z` then `x == z`\n","title":"Eq","fixity":null,"sourceSpan":{"start":[576,1],"name":"src/Prelude.purs","end":[579,1]}},{"children":[],"code":[["ident","(==)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Eq","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ctor","Boolean","Prim"]],"comments":"`(==)` is an alias for `eq`. Tests whether one value is equal to another.\n","title":"(==)","fixity":{"associativity":"infix","precedence":4},"sourceSpan":{"start":[583,1],"name":"src/Prelude.purs","end":[584,1]}},{"children":[],"code":[["ident","(/=)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Eq","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ctor","Boolean","Prim"]],"comments":"`(/=)` tests whether one value is _not equal_ to another. Shorthand for\n`not (x == y)`.\n","title":"(/=)","fixity":{"associativity":"infix","precedence":4},"sourceSpan":{"start":[588,1],"name":"src/Prelude.purs","end":[589,1]}},{"children":[{"code":[["ctor","LT",null]],"comments":null,"title":"LT","type":"dataConstructor","sourceSpan":null},{"code":[["ctor","GT",null]],"comments":null,"title":"GT","type":"dataConstructor","sourceSpan":null},{"code":[["ctor","EQ",null]],"comments":null,"title":"EQ","type":"dataConstructor","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","semigroupOrdering"],["space"],["syntax","::"],["space"],["ctor","Semigroup","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"semigroupOrdering","type":"instance","sourceSpan":{"start":[412,1],"name":"src/Prelude.purs","end":[417,1]}},{"code":[["keyword","instance"],["space"],["ident","eqOrdering"],["space"],["syntax","::"],["space"],["ctor","Eq","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"eqOrdering","type":"instance","sourceSpan":{"start":[612,1],"name":"src/Prelude.purs","end":[618,1]}},{"code":[["keyword","instance"],["space"],["ident","ordOrdering"],["space"],["syntax","::"],["space"],["ctor","Ord","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"ordOrdering","type":"instance","sourceSpan":{"start":[666,1],"name":"src/Prelude.purs","end":[675,1]}},{"code":[["keyword","instance"],["space"],["ident","boundedOrdering"],["space"],["syntax","::"],["space"],["ctor","Bounded","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"boundedOrdering","type":"instance","sourceSpan":{"start":[730,1],"name":"src/Prelude.purs","end":[734,1]}},{"code":[["keyword","instance"],["space"],["ident","boundedOrdOrdering"],["space"],["syntax","::"],["space"],["ctor","BoundedOrd","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"boundedOrdOrdering","type":"instance","sourceSpan":{"start":[751,1],"name":"src/Prelude.purs","end":[752,1]}},{"code":[["keyword","instance"],["space"],["ident","showOrdering"],["space"],["syntax","::"],["space"],["ctor","Show","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"showOrdering","type":"instance","sourceSpan":{"start":[849,1],"name":"src/Prelude.purs","end":[854,1]}}],"code":[["keyword","data"],["space"],["ctor","Ordering",null]],"comments":"The `Ordering` data type represents the three possible outcomes of\ncomparing two values:\n\n`LT` - The first value is _less than_ the second.\n`GT` - The first value is _greater than_ the second.\n`EQ` - The first value is _equal to_ or _incomparable to_ the second.\n","title":"Ordering","fixity":null,"sourceSpan":{"start":[628,1],"name":"src/Prelude.purs","end":[637,1]}},{"children":[{"code":[["ident","compare"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"compare","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","ordBoolean"],["space"],["syntax","::"],["space"],["ctor","Ord","Prelude"],["space"],["ctor","Boolean","Prim"]],"comments":null,"title":"ordBoolean","type":"instance","sourceSpan":{"start":[640,1],"name":"src/Prelude.purs","end":[643,1]}},{"code":[["keyword","instance"],["space"],["ident","ordInt"],["space"],["syntax","::"],["space"],["ctor","Ord","Prelude"],["space"],["ctor","Int","Prim"]],"comments":null,"title":"ordInt","type":"instance","sourceSpan":{"start":[643,1],"name":"src/Prelude.purs","end":[646,1]}},{"code":[["keyword","instance"],["space"],["ident","ordNumber"],["space"],["syntax","::"],["space"],["ctor","Ord","Prelude"],["space"],["ctor","Number","Prim"]],"comments":null,"title":"ordNumber","type":"instance","sourceSpan":{"start":[646,1],"name":"src/Prelude.purs","end":[649,1]}},{"code":[["keyword","instance"],["space"],["ident","ordString"],["space"],["syntax","::"],["space"],["ctor","Ord","Prelude"],["space"],["ctor","String","Prim"]],"comments":null,"title":"ordString","type":"instance","sourceSpan":{"start":[649,1],"name":"src/Prelude.purs","end":[652,1]}},{"code":[["keyword","instance"],["space"],["ident","ordChar"],["space"],["syntax","::"],["space"],["ctor","Ord","Prelude"],["space"],["ctor","Char","Prim"]],"comments":null,"title":"ordChar","type":"instance","sourceSpan":{"start":[652,1],"name":"src/Prelude.purs","end":[655,1]}},{"code":[["keyword","instance"],["space"],["ident","ordUnit"],["space"],["syntax","::"],["space"],["ctor","Ord","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"ordUnit","type":"instance","sourceSpan":{"start":[655,1],"name":"src/Prelude.purs","end":[658,1]}},{"code":[["keyword","instance"],["space"],["ident","ordArray"],["space"],["syntax","::"],["space"],["syntax","("],["ctor","Ord","Prelude"],["space"],["ident","a"],["syntax",") =>"],["space"],["ctor","Ord","Prelude"],["space"],["syntax","("],["ctor","Array","Prim"],["space"],["ident","a"],["syntax",")"]],"comments":null,"title":"ordArray","type":"instance","sourceSpan":{"start":[658,1],"name":"src/Prelude.purs","end":[664,1]}},{"code":[["keyword","instance"],["space"],["ident","ordOrdering"],["space"],["syntax","::"],["space"],["ctor","Ord","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"ordOrdering","type":"instance","sourceSpan":{"start":[666,1],"name":"src/Prelude.purs","end":[675,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","Eq","Prelude"],["space"],["ident","a"],["syntax",") <="],["space"],["ctor","Ord",null],["space"],["ident","a"],["space"],["keyword","where"]],"comments":"The `Ord` type class represents types which support comparisons.\n\n`Ord` instances should satisfy the laws of _partially orderings_:\n\n- Reflexivity: `a <= a`\n- Antisymmetry: if `a <= b` and `b <= a` then `a = b`\n- Transitivity: if `a <= b` and `b <= c` then `a <= c`\n","title":"Ord","fixity":null,"sourceSpan":{"start":[637,1],"name":"src/Prelude.purs","end":[640,1]}},{"children":[],"code":[["ident","(<)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Ord","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ctor","Boolean","Prim"]],"comments":"Test whether one value is _strictly less than_ another.\n","title":"(<)","fixity":{"associativity":"infixl","precedence":4},"sourceSpan":{"start":[681,1],"name":"src/Prelude.purs","end":[682,1]}},{"children":[],"code":[["ident","(>)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Ord","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ctor","Boolean","Prim"]],"comments":"Test whether one value is _strictly greater than_ another.\n","title":"(>)","fixity":{"associativity":"infixl","precedence":4},"sourceSpan":{"start":[687,1],"name":"src/Prelude.purs","end":[688,1]}},{"children":[],"code":[["ident","(<=)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Ord","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ctor","Boolean","Prim"]],"comments":"Test whether one value is _non-strictly less than_ another.\n","title":"(<=)","fixity":{"associativity":"infixl","precedence":4},"sourceSpan":{"start":[693,1],"name":"src/Prelude.purs","end":[694,1]}},{"children":[],"code":[["ident","(>=)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","Ord","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ctor","Boolean","Prim"]],"comments":"Test whether one value is _non-strictly greater than_ another.\n","title":"(>=)","fixity":{"associativity":"infixl","precedence":4},"sourceSpan":{"start":[699,1],"name":"src/Prelude.purs","end":[700,1]}},{"children":[{"code":[["ident","top"],["space"],["syntax","::"],["space"],["ident","a"]],"comments":null,"title":"top","type":"typeClassMember","sourceSpan":null},{"code":[["ident","bottom"],["space"],["syntax","::"],["space"],["ident","a"]],"comments":null,"title":"bottom","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","boundedBoolean"],["space"],["syntax","::"],["space"],["ctor","Bounded","Prelude"],["space"],["ctor","Boolean","Prim"]],"comments":null,"title":"boundedBoolean","type":"instance","sourceSpan":{"start":[722,1],"name":"src/Prelude.purs","end":[726,1]}},{"code":[["keyword","instance"],["space"],["ident","boundedUnit"],["space"],["syntax","::"],["space"],["ctor","Bounded","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"boundedUnit","type":"instance","sourceSpan":{"start":[726,1],"name":"src/Prelude.purs","end":[730,1]}},{"code":[["keyword","instance"],["space"],["ident","boundedOrdering"],["space"],["syntax","::"],["space"],["ctor","Bounded","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"boundedOrdering","type":"instance","sourceSpan":{"start":[730,1],"name":"src/Prelude.purs","end":[734,1]}},{"code":[["keyword","instance"],["space"],["ident","boundedInt"],["space"],["syntax","::"],["space"],["ctor","Bounded","Prelude"],["space"],["ctor","Int","Prim"]],"comments":null,"title":"boundedInt","type":"instance","sourceSpan":{"start":[734,1],"name":"src/Prelude.purs","end":[738,1]}},{"code":[["keyword","instance"],["space"],["ident","boundedFn"],["space"],["syntax","::"],["space"],["syntax","("],["ctor","Bounded","Prelude"],["space"],["ident","b"],["syntax",") =>"],["space"],["ctor","Bounded","Prelude"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"]],"comments":null,"title":"boundedFn","type":"instance","sourceSpan":{"start":[738,1],"name":"src/Prelude.purs","end":[747,1]}}],"code":[["keyword","class"],["space"],["ctor","Bounded",null],["space"],["ident","a"],["space"],["keyword","where"]],"comments":"The `Bounded` type class represents types that are finite.\n\nAlthough there are no \"internal\" laws for `Bounded`, every value of `a`\nshould be considered less than or equal to `top` by some means, and greater\nthan or equal to `bottom`.\n\nThe lack of explicit `Ord` constraint allows flexibility in the use of\n`Bounded` so it can apply to total and partially ordered sets, boolean\nalgebras, etc.\n","title":"Bounded","fixity":null,"sourceSpan":{"start":[718,1],"name":"src/Prelude.purs","end":[722,1]}},{"children":[{"code":[["keyword","instance"],["space"],["ident","boundedOrdBoolean"],["space"],["syntax","::"],["space"],["ctor","BoundedOrd","Prelude"],["space"],["ctor","Boolean","Prim"]],"comments":null,"title":"boundedOrdBoolean","type":"instance","sourceSpan":{"start":[749,1],"name":"src/Prelude.purs","end":[750,1]}},{"code":[["keyword","instance"],["space"],["ident","boundedOrdUnit"],["space"],["syntax","::"],["space"],["ctor","BoundedOrd","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"boundedOrdUnit","type":"instance","sourceSpan":{"start":[750,1],"name":"src/Prelude.purs","end":[751,1]}},{"code":[["keyword","instance"],["space"],["ident","boundedOrdOrdering"],["space"],["syntax","::"],["space"],["ctor","BoundedOrd","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"boundedOrdOrdering","type":"instance","sourceSpan":{"start":[751,1],"name":"src/Prelude.purs","end":[752,1]}},{"code":[["keyword","instance"],["space"],["ident","boundedOrdInt"],["space"],["syntax","::"],["space"],["ctor","BoundedOrd","Prelude"],["space"],["ctor","Int","Prim"]],"comments":null,"title":"boundedOrdInt","type":"instance","sourceSpan":{"start":[752,1],"name":"src/Prelude.purs","end":[783,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","Bounded","Prelude"],["space"],["ident","a"],["syntax",","],["space"],["ctor","Ord","Prelude"],["space"],["ident","a"],["syntax",") <="],["space"],["ctor","BoundedOrd",null],["space"],["ident","a"]],"comments":"The `BoundedOrd` type class represents totally ordered finite data types.\n\nInstances should satisfy the following law in addition to the `Ord` laws:\n\n- Ordering: `bottom <= a <= top`\n","title":"BoundedOrd","fixity":null,"sourceSpan":{"start":[747,1],"name":"src/Prelude.purs","end":[749,1]}},{"children":[{"code":[["ident","conj"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":null,"title":"conj","type":"typeClassMember","sourceSpan":null},{"code":[["ident","disj"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":null,"title":"disj","type":"typeClassMember","sourceSpan":null},{"code":[["ident","not"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":null,"title":"not","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","booleanAlgebraBoolean"],["space"],["syntax","::"],["space"],["ctor","BooleanAlgebra","Prelude"],["space"],["ctor","Boolean","Prim"]],"comments":null,"title":"booleanAlgebraBoolean","type":"instance","sourceSpan":{"start":[788,1],"name":"src/Prelude.purs","end":[793,1]}},{"code":[["keyword","instance"],["space"],["ident","booleanAlgebraUnit"],["space"],["syntax","::"],["space"],["ctor","BooleanAlgebra","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"booleanAlgebraUnit","type":"instance","sourceSpan":{"start":[793,1],"name":"src/Prelude.purs","end":[798,1]}},{"code":[["keyword","instance"],["space"],["ident","booleanAlgebraFn"],["space"],["syntax","::"],["space"],["syntax","("],["ctor","BooleanAlgebra","Prelude"],["space"],["ident","b"],["syntax",") =>"],["space"],["ctor","BooleanAlgebra","Prelude"],["space"],["syntax","("],["ident","a"],["space"],["syntax","->"],["space"],["ident","b"],["syntax",")"]],"comments":null,"title":"booleanAlgebraFn","type":"instance","sourceSpan":{"start":[798,1],"name":"src/Prelude.purs","end":[803,1]}}],"code":[["keyword","class"],["space"],["syntax","("],["ctor","Bounded","Prelude"],["space"],["ident","a"],["syntax",") <="],["space"],["ctor","BooleanAlgebra",null],["space"],["ident","a"],["space"],["keyword","where"]],"comments":"The `BooleanAlgebra` type class represents types that behave like boolean\nvalues.\n\nInstances should satisfy the following laws in addition to the `Bounded`\nlaws:\n\n- Associativity:\n  - `a || (b || c) = (a || b) || c`\n  - `a && (b && c) = (a && b) && c`\n- Commutativity:\n  - `a || b = b || a`\n  - `a && b = b && a`\n- Distributivity:\n  - `a && (b || c) = (a && b) || (a && c)`\n  - `a || (b && c) = (a || b) && (a || c)`\n- Identity:\n  - `a || bottom = a`\n  - `a && top = a`\n- Idempotent:\n  - `a || a = a`\n  - `a && a = a`\n- Absorption:\n  - `a || (a && b) = a`\n  - `a && (a || b) = a`\n- Annhiliation:\n  - `a || top = top`\n- Complementation:\n  - `a && not a = bottom`\n  - `a || not a = top`\n","title":"BooleanAlgebra","fixity":null,"sourceSpan":{"start":[783,1],"name":"src/Prelude.purs","end":[788,1]}},{"children":[],"code":[["ident","(&&)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","BooleanAlgebra","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":"`(&&)` is an alias for `conj`.\n","title":"(&&)","fixity":{"associativity":"infixr","precedence":3},"sourceSpan":{"start":[807,1],"name":"src/Prelude.purs","end":[808,1]}},{"children":[],"code":[["ident","(||)"],["space"],["syntax","::"],["space"],["syntax","forall"],["space"],["ident","a"],["syntax","."],["space"],["syntax","("],["ctor","BooleanAlgebra","Prelude"],["space"],["ident","a"],["syntax",")"],["space"],["syntax","=>"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ident","a"]],"comments":"`(||)` is an alias for `disj`.\n","title":"(||)","fixity":{"associativity":"infixr","precedence":2},"sourceSpan":{"start":[811,1],"name":"src/Prelude.purs","end":[812,1]}},{"children":[{"code":[["ident","show"],["space"],["syntax","::"],["space"],["ident","a"],["space"],["syntax","->"],["space"],["ctor","String","Prim"]],"comments":null,"title":"show","type":"typeClassMember","sourceSpan":null},{"code":[["keyword","instance"],["space"],["ident","showBoolean"],["space"],["syntax","::"],["space"],["ctor","Show","Prelude"],["space"],["ctor","Boolean","Prim"]],"comments":null,"title":"showBoolean","type":"instance","sourceSpan":{"start":[827,1],"name":"src/Prelude.purs","end":[831,1]}},{"code":[["keyword","instance"],["space"],["ident","showInt"],["space"],["syntax","::"],["space"],["ctor","Show","Prelude"],["space"],["ctor","Int","Prim"]],"comments":null,"title":"showInt","type":"instance","sourceSpan":{"start":[831,1],"name":"src/Prelude.purs","end":[834,1]}},{"code":[["keyword","instance"],["space"],["ident","showNumber"],["space"],["syntax","::"],["space"],["ctor","Show","Prelude"],["space"],["ctor","Number","Prim"]],"comments":null,"title":"showNumber","type":"instance","sourceSpan":{"start":[834,1],"name":"src/Prelude.purs","end":[837,1]}},{"code":[["keyword","instance"],["space"],["ident","showChar"],["space"],["syntax","::"],["space"],["ctor","Show","Prelude"],["space"],["ctor","Char","Prim"]],"comments":null,"title":"showChar","type":"instance","sourceSpan":{"start":[837,1],"name":"src/Prelude.purs","end":[840,1]}},{"code":[["keyword","instance"],["space"],["ident","showString"],["space"],["syntax","::"],["space"],["ctor","Show","Prelude"],["space"],["ctor","String","Prim"]],"comments":null,"title":"showString","type":"instance","sourceSpan":{"start":[840,1],"name":"src/Prelude.purs","end":[843,1]}},{"code":[["keyword","instance"],["space"],["ident","showUnit"],["space"],["syntax","::"],["space"],["ctor","Show","Prelude"],["space"],["ctor","Unit","Prelude"]],"comments":null,"title":"showUnit","type":"instance","sourceSpan":{"start":[843,1],"name":"src/Prelude.purs","end":[846,1]}},{"code":[["keyword","instance"],["space"],["ident","showArray"],["space"],["syntax","::"],["space"],["syntax","("],["ctor","Show","Prelude"],["space"],["ident","a"],["syntax",") =>"],["space"],["ctor","Show","Prelude"],["space"],["syntax","("],["ctor","Array","Prim"],["space"],["ident","a"],["syntax",")"]],"comments":null,"title":"showArray","type":"instance","sourceSpan":{"start":[846,1],"name":"src/Prelude.purs","end":[849,1]}},{"code":[["keyword","instance"],["space"],["ident","showOrdering"],["space"],["syntax","::"],["space"],["ctor","Show","Prelude"],["space"],["ctor","Ordering","Prelude"]],"comments":null,"title":"showOrdering","type":"instance","sourceSpan":{"start":[849,1],"name":"src/Prelude.purs","end":[854,1]}}],"code":[["keyword","class"],["space"],["ctor","Show",null],["space"],["ident","a"],["space"],["keyword","where"]],"comments":"The `Show` type class represents those types which can be converted into\na human-readable `String` representation.\n\nWhile not required, it is recommended that for any expression `x`, the\nstring `show x` be executable PureScript code which evaluates to the same\nvalue as the expression `x`.\n","title":"Show","fixity":null,"sourceSpan":{"start":[824,1],"name":"src/Prelude.purs","end":[827,1]}}]}],"resolvedDependencies":{},"bookmarks":[{"package":null,"item":["Prelude","Unit"]},{"package":null,"item":["Prelude","unit"]},{"package":null,"item":["Prelude","($)"]},{"package":null,"item":["Prelude","(#)"]},{"package":null,"item":["Prelude","($)"]},{"package":null,"item":["Prelude","(#)"]},{"package":null,"item":["Prelude","flip"]},{"package":null,"item":["Prelude","const"]},{"package":null,"item":["Prelude","asTypeOf"]},{"package":null,"item":["Prelude","otherwise"]},{"package":null,"item":["Prelude","Semigroupoid"]},{"package":null,"item":["Prelude","semigroupoidFn"]},{"package":null,"item":["Prelude","(>>>)"]},{"package":null,"item":["Prelude","(<<<)"]},{"package":null,"item":["Prelude","(<<<)"]},{"package":null,"item":["Prelude","(>>>)"]},{"package":null,"item":["Prelude","Category"]},{"package":null,"item":["Prelude","categoryFn"]},{"package":null,"item":["Prelude","Functor"]},{"package":null,"item":["Prelude","functorFn"]},{"package":null,"item":["Prelude","functorArray"]},{"package":null,"item":["Prelude","(<$>)"]},{"package":null,"item":["Prelude","(<#>)"]},{"package":null,"item":["Prelude","(<$>)"]},{"package":null,"item":["Prelude","(<#>)"]},{"package":null,"item":["Prelude","void"]},{"package":null,"item":["Prelude","Apply"]},{"package":null,"item":["Prelude","applyFn"]},{"package":null,"item":["Prelude","applyArray"]},{"package":null,"item":["Prelude","(<*>)"]},{"package":null,"item":["Prelude","(<*>)"]},{"package":null,"item":["Prelude","Applicative"]},{"package":null,"item":["Prelude","applicativeFn"]},{"package":null,"item":["Prelude","applicativeArray"]},{"package":null,"item":["Prelude","return"]},{"package":null,"item":["Prelude","liftA1"]},{"package":null,"item":["Prelude","Bind"]},{"package":null,"item":["Prelude","bindFn"]},{"package":null,"item":["Prelude","bindArray"]},{"package":null,"item":["Prelude","(>>=)"]},{"package":null,"item":["Prelude","(>>=)"]},{"package":null,"item":["Prelude","Monad"]},{"package":null,"item":["Prelude","monadFn"]},{"package":null,"item":["Prelude","monadArray"]},{"package":null,"item":["Prelude","liftM1"]},{"package":null,"item":["Prelude","ap"]},{"package":null,"item":["Prelude","Semigroup"]},{"package":null,"item":["Prelude","(<>)"]},{"package":null,"item":["Prelude","(++)"]},{"package":null,"item":["Prelude","(<>)"]},{"package":null,"item":["Prelude","(++)"]},{"package":null,"item":["Prelude","semigroupString"]},{"package":null,"item":["Prelude","semigroupUnit"]},{"package":null,"item":["Prelude","semigroupFn"]},{"package":null,"item":["Prelude","semigroupOrdering"]},{"package":null,"item":["Prelude","semigroupArray"]},{"package":null,"item":["Prelude","Semiring"]},{"package":null,"item":["Prelude","semiringInt"]},{"package":null,"item":["Prelude","semiringNumber"]},{"package":null,"item":["Prelude","semiringUnit"]},{"package":null,"item":["Prelude","(+)"]},{"package":null,"item":["Prelude","(*)"]},{"package":null,"item":["Prelude","(+)"]},{"package":null,"item":["Prelude","(*)"]},{"package":null,"item":["Prelude","Ring"]},{"package":null,"item":["Prelude","ringInt"]},{"package":null,"item":["Prelude","ringNumber"]},{"package":null,"item":["Prelude","ringUnit"]},{"package":null,"item":["Prelude","(-)"]},{"package":null,"item":["Prelude","(-)"]},{"package":null,"item":["Prelude","negate"]},{"package":null,"item":["Prelude","ModuloSemiring"]},{"package":null,"item":["Prelude","moduloSemiringInt"]},{"package":null,"item":["Prelude","moduloSemiringNumber"]},{"package":null,"item":["Prelude","moduloSemiringUnit"]},{"package":null,"item":["Prelude","(/)"]},{"package":null,"item":["Prelude","(/)"]},{"package":null,"item":["Prelude","DivisionRing"]},{"package":null,"item":["Prelude","divisionRingNumber"]},{"package":null,"item":["Prelude","divisionRingUnit"]},{"package":null,"item":["Prelude","Num"]},{"package":null,"item":["Prelude","numNumber"]},{"package":null,"item":["Prelude","numUnit"]},{"package":null,"item":["Prelude","Eq"]},{"package":null,"item":["Prelude","(==)"]},{"package":null,"item":["Prelude","(/=)"]},{"package":null,"item":["Prelude","(==)"]},{"package":null,"item":["Prelude","(/=)"]},{"package":null,"item":["Prelude","eqBoolean"]},{"package":null,"item":["Prelude","eqInt"]},{"package":null,"item":["Prelude","eqNumber"]},{"package":null,"item":["Prelude","eqChar"]},{"package":null,"item":["Prelude","eqString"]},{"package":null,"item":["Prelude","eqUnit"]},{"package":null,"item":["Prelude","eqArray"]},{"package":null,"item":["Prelude","eqOrdering"]},{"package":null,"item":["Prelude","Ordering"]},{"package":null,"item":["Prelude","Ord"]},{"package":null,"item":["Prelude","ordBoolean"]},{"package":null,"item":["Prelude","ordInt"]},{"package":null,"item":["Prelude","ordNumber"]},{"package":null,"item":["Prelude","ordString"]},{"package":null,"item":["Prelude","ordChar"]},{"package":null,"item":["Prelude","ordUnit"]},{"package":null,"item":["Prelude","ordArray"]},{"package":null,"item":["Prelude","ordOrdering"]},{"package":null,"item":["Prelude","(<)"]},{"package":null,"item":["Prelude","(>)"]},{"package":null,"item":["Prelude","(<=)"]},{"package":null,"item":["Prelude","(>=)"]},{"package":null,"item":["Prelude","(<)"]},{"package":null,"item":["Prelude","(>)"]},{"package":null,"item":["Prelude","(<=)"]},{"package":null,"item":["Prelude","(>=)"]},{"package":null,"item":["Prelude","Bounded"]},{"package":null,"item":["Prelude","boundedBoolean"]},{"package":null,"item":["Prelude","boundedUnit"]},{"package":null,"item":["Prelude","boundedOrdering"]},{"package":null,"item":["Prelude","boundedInt"]},{"package":null,"item":["Prelude","boundedFn"]},{"package":null,"item":["Prelude","BoundedOrd"]},{"package":null,"item":["Prelude","boundedOrdBoolean"]},{"package":null,"item":["Prelude","boundedOrdUnit"]},{"package":null,"item":["Prelude","boundedOrdOrdering"]},{"package":null,"item":["Prelude","boundedOrdInt"]},{"package":null,"item":["Prelude","BooleanAlgebra"]},{"package":null,"item":["Prelude","booleanAlgebraBoolean"]},{"package":null,"item":["Prelude","booleanAlgebraUnit"]},{"package":null,"item":["Prelude","booleanAlgebraFn"]},{"package":null,"item":["Prelude","(&&)"]},{"package":null,"item":["Prelude","(||)"]},{"package":null,"item":["Prelude","(&&)"]},{"package":null,"item":["Prelude","(||)"]},{"package":null,"item":["Prelude","Show"]},{"package":null,"item":["Prelude","showBoolean"]},{"package":null,"item":["Prelude","showInt"]},{"package":null,"item":["Prelude","showNumber"]},{"package":null,"item":["Prelude","showChar"]},{"package":null,"item":["Prelude","showString"]},{"package":null,"item":["Prelude","showUnit"]},{"package":null,"item":["Prelude","showArray"]},{"package":null,"item":["Prelude","showOrdering"]}],"version":"999.0.1","github":["purescript","purescript-prelude"],"versionTag":"v999.0.1"}
